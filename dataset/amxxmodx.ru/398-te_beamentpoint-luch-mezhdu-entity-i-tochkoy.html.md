# TE_BEAMENTPOINT - Луч между entity и точкой
[Ядро AMXx](http://amxxmodx.ru/core/) [message_const.inc](http://amxxmodx.ru/core/message_constinc/)
Данная мессага похожа на TE_BEAMPOINTS, но в них есть одно большое отличие теперь луч проходит между entity и точкой.  
  
```
#define    TE_BEAMENTPOINT             1        // Beam effect between point and entity  
// write_byte(TE_BEAMENTPOINT)  
// write_short(start entity)   
// write_coord(endposition.x)  
// write_coord(endposition.y)  
// write_coord(endposition.z)  
// write_short(sprite index)   
// write_byte(starting frame)   
// write_byte(frame rate in 0.1's)   
// write_byte(life in 0.1's)   
// write_byte(line width in 0.1's)   
// write_byte(noise amplitude in 0.01's)   
// write_byte(red)  
// write_byte(green)  
// write_byte(blue)  
// write_byte(brightness)  
// write_byte(scroll speed in 0.1's)
```
  
  
**Синтаксис:**  
Для того что бы создать сообщения нужно объявить по началу message_begin, а по окончанию message_end.  
  
**Пример:**  
```
/* Plugin generated by AMXX-Studio */  
  
#include <amxmodx>  
#include <amxmisc>  
#include <hamsandwich>  
  
#define PLUGIN "Messages[TE_BEAMENTPOINT]"  
#define VERSION "0.1"  
#define AUTHOR "Mon[str]"  
  
#define bit_add_laser(%0)        g_bitLaser |= 1 << (%0 - 1)  
#define bit_sub_laser(%1)        g_bitLaser &= ~(1 << (%1 - 1))  
#define bit_is_laser(%2)        g_bitLaser & 1 << (%2 - 1)  
  
#define bit_add_alive(%3)        g_bitAlive |= 1 << (%3 - 1)  
#define bit_sub_alive(%4)        g_bitAlive &= ~(1 << (%4 - 1))  
#define bit_is_alive(%5)        g_bitAlive & 1 << (%5 - 1)  
  
  
new g_bitLaser;  
new g_bitAlive;  
  
new g_iBeamSprite;  
  
public plugin_precache()  
{  
    /* Возьмем индекс данного спрайта */  
    g_iBeamSprite = precache_model("sprites/laserbeam.spr");  
}  
  
public plugin_init()   
{  
    register_plugin(PLUGIN, VERSION, AUTHOR);  
      
    /* Зарегистрируем Ham_* евенты */  
    RegisterHam(Ham_Spawn, "player", "Ham_Spawn_Player_Post", 1);  
    RegisterHam(Ham_Killed, "player", "Ham_Killed_Player_Post", 1);  
    RegisterHam(Ham_Player_PreThink, "player", "Ham_Think_Player_Pre");  
      
    /* Зарегистрируем команды для включенния и выключения луча */  
    register_concmd("+laser", "Plus_Laser");  
    register_concmd("-laser", "Minus_Laser");  
      
    register_cvar("Amplitude", "0");  
    register_cvar("Line", "0");  
}  
  
public Ham_Spawn_Player_Post(id)  
{  
    /* При спавне ставим бит-сумму на true(Альтернатива is_user_alive()) */  
    bit_add_alive(id);  
}  
  
public Ham_Killed_Player_Post(iVictim, iWeapon, iAttacker)  
{  
    /* При смерти савим бит-сумму на false(Альтернатива is_user_alive()) */  
    bit_sub_alive(iVictim);  
}  
  
public Ham_Think_Player_Pre(id)  
{  
    /* Если игрок жив и если игрок зажал кнопку */  
    if(bit_is_alive(id) && bit_is_laser(id))  
    {  
        static iAimOrigin[3];  
          
        /* Берем аим координаты игрока */  
        get_user_origin(id, iAimOrigin, 3);  
          
        /* Создаем сообщение */  
        message_begin(MSG_BROADCAST, SVC_TEMPENTITY);  
        write_byte(TE_BEAMENTPOINT);  
        write_short(id);             //Индекс entity  
        write_coord(iAimOrigin[0]);          //Конечная точка x  
        write_coord(iAimOrigin[1]);         //Конечная точка y  
        write_coord(iAimOrigin[2]);          //Конечная точка z  
        write_short(g_iBeamSprite);         //Индекс спрайта   
        write_byte(0)                 //Стартовый кадр  
        write_byte(1);                 //Скорость анимации  
        write_byte(1);                //Врмея существования  
        write_byte(get_cvar_num("Line"));    //Толщина луча  
        write_byte(get_cvar_num("Amplitude"));  //Искажение  
          
        /* Делаем рандом из 3 кейсов */  
        switch(random(3))  
        {  
            case 0:  
            {  
                write_byte(255);    //Цвет красный  
                write_byte(0);        //Цвеи зеленый  
                write_byte(0);        //Цвет синий  
            }  
              
            case 1:  
            {  
                write_byte(0);        //Цвет красный  
                write_byte(255);    //Цвеи зеленый  
                write_byte(0);        //Цвет синий  
            }  
              
            case 2:  
            {  
                write_byte(0);        //Цвет красный  
                write_byte(0);        //Цвеи зеленый  
                write_byte(255);    //Цвет синий  
            }  
        }  
          
        write_byte(2000);            //Яркость  
        write_byte(0);                //...  
        message_end();  
    }  
}  
  
public Plus_Laser(id)  
{  
    /*Если игрок зажал забинденную кнопку то бит-сумму ставим на true*/  
    bit_add_laser(id);  
          
    return 1;      
}  
  
public Minus_Laser(id)  
{  
    /*Если игрок отжал забинденную кнопку то бит-сумму ставим на false*/  
    bit_sub_laser(id);  
          
    return 1;      
}
```
  
  
PS  
В коде используются действия с битами, [Урок 9. Биты, битовые поля, операции](http://amxxmodx.ru/engine/go.php?url=aHR0cDovL2FteHhtb2R4LnJ1L2xlc3NvbnMtb24tcGF3bi8yNDMtdXJvay05LWJpdHktYml0b3Z5ZS1wb2x5YS1vcGVyYWNpaS5odG1s)  
  

