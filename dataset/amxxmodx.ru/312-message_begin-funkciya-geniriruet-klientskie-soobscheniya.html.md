# message_begin Функция генирирует клиентские сообщения.
[Ядро AMXx](http://amxxmodx.ru/core/) [messages.inc ](http://amxxmodx.ru/core/messagesinc/)
Увидев заголовок, вы наверное подумали о том что уже знаете функцию с помощью которой можно вывести клиенту какое то текстовое сообщение, но функция **message_begin** имеет значительно больший функционал, чем просто вывод текстового сообщения. С ее помощью можно создать молнию, дым, взрывы, эффект крови и многое другое, на что хватит вашей фантазии в рамках возможности функции.  
  
Инфо из **messages.inc:**  
```
/* These functinos are used to generate client messages.  
 * You may generate menu, smoke, shockwaves, thunderlights,  
 * intermission and many many others messages.  
 * See HL SDK for more examples. */  
native message_begin(dest, msg_type, const origin[3] = {0,0,0}, player = 0);
```
  
  
**Синтаксис:**  

message_begin(dest, msg_type, const origin[3] = {0,0,0}, player = 0)
  

    * **dest** - Кому отправлять сообщение  
```
//Destination types for message_begin()  
#define MSG_BROADCAST        0    //Сообщение всем игрокам без гарантии доставки  
#define MSG_ONE            1    //Сообщение одному игроку с гарантией доставки  
#define MSG_ALL            2    //Сообщение с гарантией доставки всем игрокам  
#define MSG_INIT            3    //Write to the init string  
#define MSG_PVS            4    //Всем игрокам в зоне видимости точки  
#define MSG_PAS            5    //Всем игрокам в зоне слышимости  
#define MSG_PVS_R        6    //Всем игрокам в зоне видимости точки с гарант. доставки  
#define MSG_PAS_R        7    //Всем игрокам в зоне слышимости с гарант. доставки  
#define MSG_ONE_UNRELIABLE    8    //Сообщение одному игроку, без гарантии доставки  
#define MSG_SPEC        9    //Сообщение всем HLTV proxy
```
  

    * **msg_type** - Тип создаваемого сообщения.   
```
//Message types for message_begin()  
#define SVC_TEMPENTITY        23  
#define SVC_INTERMISSION    30  
#define SVC_CDTRACK        32  
#define SVC_WEAPONANIM        35  
#define SVC_ROOMTYPE        37  
#define SVC_ADDANGLE        38  
#define SVC_NEWUSERMSG        39  
#define SVC_HLTV        50
```
  

    * **const origin[3] = {0,0,0}** - Координата точки для режимов MSG_PVS, MSG_PAS, MSG_PVS_R, MSG_PAS_R  

    * **player = 0** - id игрока  

Функция вернет 1 если сообщение отправлено и 0 если нет.  
  
Функции которые используются совместно с **message_begin** :  

    * write_byte  

    * write_char  

    * write_short  

    * write_long  

    * write_entity  

    * write_angle  

    * write_coord  

    * write_string  

  
  
**Внимание:**  
Прежде, чем вызывать следующую **message_begin** необходимо вызвать функцию **message_end**. Иначе это может привести к падению сервера.  
  
**Тип функции:**  
Native  
  
**Пример:**  
Ниже код для двух случаев из многих, предвкушая вопрос от куда я узнал о SVC_TEMPENTITY,TE_BLOODSTREAM и где взять информацию, отвечаю:  
Вся необходимая информация есть в **message_const.inc** , точнее много информации по TE_* константам, а о SVC_* отправляют в HLSDK  
```
/* Plugin generated by AMXX-Studio */  
  
#include <amxmodx>  
#include <amxmisc>  
  
#define PLUGIN "[messagemode.inc] message_begin"  
#define VERSION "1.0"  
#define AUTHOR "Admin"  
  
//переменная для айди спрайта и массив для сеттасков  
new sprite  
new arg[1]  
  
public plugin_init() {  
    register_plugin(PLUGIN, VERSION, AUTHOR)  
      
    //Регистрация двух команд для примеров  
    register_clcmd("say /sprite","startsprite")  
    register_clcmd("say /blood","startblood")  
      
}  
//Кешируем спрайт  
public plugin_precache(){  
      
    sprite = precache_model("sprites/black_smoke1.spr")  
      
}  
//Функция вызывающая функцию создания спрайта каждую секунду  
public startsprite(id){  
      
    arg[0] = id  
    set_task(1.0, "my_first_sprite", 3, arg, 1, "b")  
      
}  
//Функция создающая спрайт  
public my_first_sprite(arg[0]){  
      
    //Получаем координаты для спрайта  
    new origin[3]  
    get_user_origin(arg[0],origin,0)  
    origin[1] += 100  
      
    //Говорим что хотим создать временный объект и показать одному игроку  
    message_begin(MSG_ONE,SVC_TEMPENTITY,origin,arg[0])  
    write_byte(TE_SPRITE)//говорим что хотим создать, в данном случае спрайт  
    write_coord(origin[0])//х - координата  
    write_coord(origin[1])//у - координата  
    write_coord(origin[2])//z - координата  
    write_short(sprite)// id спрайта  
    write_byte(5) //масштаб  
    write_byte(100)//яркость  
    message_end()  
      
}  
//Вызов функции создания крови  
public startblood(id){  
      
    arg[0] = id  
    set_task(1.0, "blood", 3, arg, 1, "b")  
      
}  
//Функция создающая кровь  
public blood(arg[]){  
      
    //Получение координат игрока  
    new origin[3]  
    get_user_origin(arg[0],origin,0)  
    origin[0] += 100  
  
    //Создание временного объекта, который будет показан всем кто сможет увидеть  
    message_begin(MSG_BROADCAST,SVC_TEMPENTITY)  
    write_byte(TE_BLOODSTREAM)//Объект "кровоток"  
    write_coord(origin[0])//х - Координата  
    write_coord(origin[1])//у - Координата  
    write_coord(origin[2]+10)//z - Координата  
    write_coord(random_num(-100,100))//Вектор направления крови х  
    write_coord(random_num(-100,100))//Вектор направления крови у  
    write_coord(random_num(-10,10))//Вектор направления крови z  
    write_byte(70)//Цвет  
    write_byte(random_num(50,100))//Скорость  
    message_end()  
      
}
```
  
  
**Описание:**  
Я постарался максимально подробно снабдить код комментариями, что бы вам не пришлось накладывать описание на код.  
Вам остается только попробовать две команды, и разобраться что от чего зависит.  
А дальше изучать содержимое фала **message_cons.inc**  

