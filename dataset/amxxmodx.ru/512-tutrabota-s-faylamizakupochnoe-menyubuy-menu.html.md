# [TUT] Работа с файлами (Закупочное меню/Buy Menu)
[Присланное](http://amxxmodx.ru/other/)
я не буду вкладывать сюда уже готового сма, просто объясню сам алгоритм работы и приведу примеры.  
Заполнение файла из которого будет браться иноформация для меню будет выглядеть примерно так  

[WEAPON ON] - начало раздела  
"Deset Eagle" "1500" "weapon_deagle" - "Название в меню" "Цена" "Оружие или название вещи из zp_extraitems.ini"  
"Fire Nade" "200" "Napalm Nade"  
[WEAPON OFF] - конец определенного раздела
  
Меню я буду делать для зомби сервера на основе ZP4.3(легко можно на паблик поменять)  
Первым делом нам нужно создать пару глобальных массивов в которых будет лежать информация из нашего файла  
  
Пример:  
```
new g_WeaponName[10][128], g_WeaponTodo[10][128], Float:g_WeaponCost[10], bool:g_WeaponCategory, g_WeaponCounter
```
  
Где первый размер массива(у меня 10) это максимальное кол-во отдельно взятых вещей из файла(для Бай меню это оружие), а второй размер массива(128) - это макс. кол-во символов для последующей записи информации из файла в этот массив  
Далее вы узнаете зачем нам нужны эти массивы/переменные  
  
Далее в ```
public plugin_precache()
```
  
  
Считываем и записываем информацию  
```
new file = fopen("addons/amxmodx/configs/test.txt","rt") // Открываем файл для чтения из опр. дериктории  
   
new linedata[1024]//Массив для чтения строки  
          
while (!feof(file))//Делаем цикл , проверка: "пока не закончится файл"  
{  
        fgets(file, linedata, charsmax(linedata))//получает поочередно 1 строку из файла и записывает её в linedata  
                  
        replace(linedata, charsmax(linedata), "^n", "")//Удаляем пустые строки(заменяем их на пустой символ)  
                  
        if( equali(linedata, "[WEAPON ON]") ) //Если строка совпадает "[WEAPON ON]", то меняем булевевую переменную на "правду"(1), это в дальнейшем пригодится нам для доставания информации  
                g_WeaponCategory = true  
                  
        if( equali(linedata, "[PISTOL OFF]") ) // Если"[PISTOL OFF]", тогда меняем на "ложь"(0)  
                g_WeaponCategory = false  
                  
        new WeaponCost[10][10] //Создаем новый массив, в который мы будет принимать информацию о цене, а позже записывать её в глобальный массив, где первый размер это макс. кол-во пунктов из файла, а второй размер нужен для записывания цены(макс. кол-во символов), не больше 10 , как правило  
                  
        if(g_WeaponCategory && (linedata[0] == '"')) // Если наша булевая переменная равняется "правде"(1) и первый знак в строке является кавычками, то...  
        {  
                parse(linedata, g_WeaponName[g_WeaponCounter], 127, WeaponCost[g_WeaponCounter], 9, g_WeaponTodo[g_WeaponCounter], 127)// Достаем поочередно информацию из файла, сначала имя, потом цена, потом Todo(индикатор того, что мы будем выдавать)  
   
                g_WeaponCost[g_WeaponCounter] = floatstr(WeaponCost[g_WeaponCounter]) //Пишем что наша "глобальная цена" равняется конвертированной из строки в дробное число - WeaponCost, я думаю все понимают, что g_WeaponCounter нужен для поочередного чтения информации  
                          
                g_WeaponCounter++//+1 каждый раз к этой переменной, что бы очередь сохраняла свой порядок  
        }
```
  
  
Такс, здесь просиходит цикл, каждый раз считывай новую строку мы делаем ряд проверок, вот таким способом вы можете получить иноформацию из файла, вид оформления в фале я описал в начале темы  
  
Именно таким способом получаю я  
  
Далее, допустим мы хотим добавить в меню пункты  
  
Создаем меню:  
в ```
public plugin_init()
```
(если это будет статическое меню)  
  
Регистрируем меню  
```
g_PMenu = menu_create("Weapon Menu", "PMenuHandler")
```
  
  
Добавляем предмет(после создания меню вставлять):  
```
new Message[128]  
          
for(new i; i <= g_WeaponCounter; i++)//Цикл делаем  
{  
        if(g_WeaponCost[i] == 0) что бы не было пустой строки  
                return;  
                          
        formatex(Message, 127, "%s \r[%d$]", g_PistolName[i], floatround(g_PistolCost[i]))//Форматируем название каждого пункта  
                  
        menu_additem(g_PMenu, Message)  
}[/pawn]  
В хандлер функции меню делаем следующее(на зомби сервер):  
[pawn]public PMenuHandler(id, menu, item)  
{  
        if(g_WeaponTodo[item][0] == 'w' && g_WeaponTodo[item][1] == 'e' && g_WeaponTodo[item][2] == 'a')// Проверяем , содержит ли индефикатор первый знаки "wea" , от стандартных оружий (weapon_awp)  
        {  
                give_item(id, g_WeaponTodo[item])//Если содержит то выдаем с помощью этого натива  
        }  
        else  
        {  
                zp_force_buy_extra_item(id, zp_get_extra_item_id(g_WeaponTodo[item]), true)//Если же нет, то выдаем бесплатно вещь из Extra Items , используя ZP  
        }  
          
        cs_set_user_money(id, cs_get_user_money(id) - floatround(g_WeaponCost[item]))//Снимаем деньги  
}
```
  
  
Вроде все, краткий гайд закончен, я уж не говорю о том, что нужно подключать инклюды, блокирвать предмет с помощью CallBack если не хватает денег, создавать переменную к меню, не буду объянснять аргументы от menu_create, и других нативов, т.к. это есть в свободном доступе и т.д.  
  
Как и обещал, дал основной код, даже прокомментировал все мои действия, при моих тестах все работало, вы можете это использовать как захотите, можете модифицировать по желанию, можете закрыть тему без каких либо последующих действий , дело ваше)
