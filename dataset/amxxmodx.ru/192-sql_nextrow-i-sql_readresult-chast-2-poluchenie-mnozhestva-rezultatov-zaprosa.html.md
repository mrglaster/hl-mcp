# SQL_NextRow и SQL_ReadResult Часть 2. Получение множества результатов запроса.
[SQLx](http://amxxmodx.ru/sqlx/)
Функция **SQL_NextRow** сама по себе бесполезна, но без нее будет очень сложно организовать вывод неизвестного количества результатов запроса из базы данных. Неизвестного результата, потому что мы не можем всегда знать сколько строк вернет база данных по запросу.  
  
Инфо из **sqlx.inc:**  
```
/**  
 * Advances to the next result (return value should be ignored).  
 */  
native SQL_NextRow(Handle:query);  

```
  
  
**Синтаксис:**  

SQL_NextRow ( Handle:query )
  

    * **Handle:query** - Идентификатор запроса  

  
  
**Тип функции:**  
Native  
  
**Пример:**  
```
/* Plugin generated by AMXX-Studio */  
  
#include <amxmodx>  
#include <amxmisc>  
#include <sqlx>  
  
#define PLUGIN "[SQLx.inc] SQL_NextRow and SQL_ReadResult"  
#define VERSION "1.0"  
#define AUTHOR "Admin"  
  
new Handle:SQL_Tuple  
new Handle:SQL_Connection   
  
public plugin_init() {  
      
    register_plugin(PLUGIN, VERSION, AUTHOR)  
    register_cvar("SQLx_host","127.0.0.1")  
    register_cvar("SQLx_db","amxxmodx")  
    register_cvar("SQLx_user","admin")  
    register_cvar("SQLx_password","pass")  
      
    register_concmd("select_sql","sqlx_select")  
}  
public plugin_cfg(){  
    new host[33],dbase[33],user[33],pass[33]  
    get_cvar_string("SQLx_host",host,30)  
    get_cvar_string("SQLx_db",dbase,30)  
    get_cvar_string("SQLx_user",user,30)  
    get_cvar_string("SQLx_password",pass,30)  
    SQL_Tuple = SQL_MakeDbTuple(host,user,pass,dbase) // Создание картежа данных для соединения с БД  
    new err, error[256]  
    SQL_Connection = SQL_Connect(SQL_Tuple, err, error, charsmax(error)) // Соединение с БД  
      
    if(SQL_Connection != Empty_Handle)  
    {  
        log_amx("[SQLx connect ok]") //Если соединение установлено   
        }else{  
        log_amx("[SQLX sql error] %s ",error) //Если нет и выводим причину(ошибку)  
        pause("a")  
    }  
      
}  
public sqlx_select(id){  
      
    //Подготовка Запроса  
    new Handle:query = SQL_PrepareQuery(SQL_Connection,"SELECT * FROM `dle_files`")  
    // Выполняем запрос к базе даанных  
    SQL_Execute (query)  
  
    while(SQL_MoreResults(query)){  
      
        new id = SQL_ReadResult(query, 0)   
        new str[32]   
        SQL_ReadResult(query, 1, str, 31)  
        new name[32]  
        SQL_ReadResult(query, 2, name, 31)  
      
        server_print("SQL Select Result: %d %s %s",id,str,name)  
          
        SQL_NextRow(query)  
    }  
}  
public plugin_end(){  
  
    SQL_FreeHandle(SQL_Connection)  
  
}  

```
  
  
**Описание:**  
Зачем нужна функция которая получает следующую строку из полученных результатов?  
Давайте немного порассуждаем:  
  
Задача: Получить N строк из базы данных.  
  
Решение:  
Создаем запрос к базе данных, выполняем его.   
База данных вернула к примеру 3 строки ( но мы не можем знать сколько точно она вернула)  
  
Функция SQL_ReadResult - получит только первую строку из запроса.  
Как же получить следующие 2 строки?   
  
Напрашивается вывод: Попросить следующий результат (строку) с помощью функции SQL_NextRow.  
Но так как мы не знаем сколько точно будет строк, как нам это организовать? написать 10 одинаковых функций и каждый раз проверять все 10?  
А если их 100 ил 1000? будет и не красивый код и по ресурсам не выгодно.  
  
Решение этой задачи использовать цикл **while** , в условии которого стоит функция которая проверяет есть ли результат, а в его конце функция которая спрашивает следующий результат, то етсь получается замкнутая система, и пока не будут выбраны все строки из результата, цикл будет повторяться, как только результаты закончатся цикл прекратиться.  
  
Вот как это выглядит в коде:  
```
public sqlx_select(id){  
      
    //Подготовка Запроса  
    new Handle:query = SQL_PrepareQuery(SQL_Connection,"SELECT * FROM `table`")  
    // Выполняем запрос к базе даанных  
    SQL_Execute (query)  
  
    //Цикл с условием что результат от запроса есть  
    while(SQL_MoreResults(query)){  
      
        //Получение результатов  
        new id = SQL_ReadResult(query, 0)   
        new steamid[32]   
        SQL_ReadResult(query, 1, steamid, 31)  
        new name[32]  
        SQL_ReadResult(query, 2, name, 31)  
  
        //Вывод результатов в консоль  
        server_print("SQL Select Result: %d %s %s",id,steamid,name)  
  
        //Функция которая обращается к следующей строке результата          
        SQL_NextRow(query)  
    }  
}
```
  
Ну как, все понятно?  
Результатом работы будет примерно следующие:  

SQL Select Result: 1 Steamxxx Admin  
SQL Select Result: 2 Steamyyy Player1  
SQL Select Result: 3 Vlalvezzz Player2
  
Разумеется все зависит от вашей таблицы с данными.
