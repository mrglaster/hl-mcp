# Урок 24. Позиция,скорость и углы в Half-Life (Position, Velocity, and Angles)
[Уроки по скриптингу для начинающих](http://amxxmodx.ru/lessons-on-pawn/)
Это руководство будет полезно новичкам с желанием узнать о **Position**(позиции), **Velocity**(скорости) и **Anglesd**(углах). Для того что бы понимать разницу в этих понятиях и успешно применять эти знания на практике.  
  

## Dimensions - размерности
  
**Dimensions** - размеры, величина, объём, протяжение  
  
0th dimension - нулевая размерность  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868430_1.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868430_1.png)  
На картинке показана точка, которая не имеет ни какого размера. И у нас нет ни какой системы координат, что не позволит нам определить ее положение как на плоскости так и в пространстве.  
  
1st dimension - одномерная размерность  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868445_2.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868445_2.png)  
В данном случае у на сесть линия. И мы может измерить только ее длину.(Много проблем в физике идеализированы к одномерным проблемам для простоты. Например, падающие тела часто идеализируются, чтобы упасть прямо вниз без отклонения.)  
  
Данная размерность позволяет нам работать только с одним числом. Например, прямая линия от пола до потолка. Скажем, пол 0, потолок 2.5 метра. Любая точка промежуточный была бы между 0 и 2.5. В коде это выглядело бы так:  
```
new Float:fHeight  
fHeight = 2.3
```
  
Речь идет о одномерной размерности, то есть тут нет никакого направления от пола к потолку. Тут есть только начало к конец.  
  
2nd dimension - двумерная размерность  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868424_3.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868424_3.png)  
Добрались до более интересного! Теперь мы можем перемещаться вверх,вниз,влево и вправо.  
МЫ можем определить расположение точки в двумерной размерности с помощью пары чисел. Эта пара чисел называется координаты. В школе обычно х записывали как **( X , Y)** , где по оси X направления влево и вправо ( от центра ) , а по оси Y верх и вниз.  
В коде для записи какой точки придется применить массив (можно и сделать две переменные, но массив удобнее):  
```
new Float:fPosition[2]
```
  
Первое значение массива будет занимать значение по оси X, второе значение по оси Y. Можно и наоборот поместить данные в массив, но лучше придерживаться схемы **X-Y-Z** , это позволит всем с легкостью читать ваш код.  
  
Пример координат вы можете посмотреть с расположением **HUD** сообщения на экране:  
```
public MakeHudMessage( id )  
{  
    //X диапазонов значений от 0 до 1, 0 являются левым краем экрана, 1 правый край экрана  
    //Y диапазон значений от 0 до 1, 0 верхний край экрана, 1 нижний край экрана  
      
    new Float:fPosition[2]  
      
    fPosition[0] = 0.2 // x position  
    fPosition[1] = 0.5 // y position  
      
    set_hudmessage( 200, 100, 0, fPosition[0], fPosition[1], 0, 6.0, 12.0, 0.1, 0.2, 4 )  
      
    // red = 200, green = 100, blue = 0  
    // x position = 0.2, y position = 0.5  
    // effects = 0  
    // fxtime = 6.0  
    // holdtime = 12.0  
    // fadeintime = 0.1, fadeouttime = 0.2  
    // channel = 4  
      
    show_hudmessage( id, "Hi this is a hudmessage!" )  
}
```
  
  
3rd dimension - трехмерная размерность  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868490_4.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868490_4.png)  
Вот теперь мы сможем переместиться вверх, вниз, вперед, назад, влево,вправо или в любое направление.  
  
Мы можем определить расположение в трех измерениях с помощью группы из трех чисел. Обычно это координаты (X, Y, Z). Где добавилось к предыдущим направлениям **Z** - направление вперед и назад. На плоскости это нарисовать не возможно, вернее это была бы точка по центру, что не наглядно.На картинках ниже должно быть понятно о чем идет речь.  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868405_3d4.jpg)](http://amxxmodx.ru/uploads/posts/2012-11/1353868405_3d4.jpg)  
  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868439_3d5.jpg)](http://amxxmodx.ru/uploads/posts/2012-11/1353868439_3d5.jpg)  
  
В коде же необходим массив на 3 ячейки для записи координат в трехмерном пространстве:  
```
new Float:fPosition[3]
```
  

    * fPosition[0] координата по оси X  

    * fPosition[1] координата по оси Y  

    * fPosition[2] координата по оси Z  

  
Вот простейший пример кода, выполнение которого перенесет игрока на 20 юнитов выше чем он стоял ( как будто был мини прыжок)  
```
public PlayWithOrigins( id )  
{  
    new iOrigin[3]  
  
    get_user_origin( id, iOrigin )  
      
    // move the player 20 units in the Z-direction (upwards)  
    iOrigin[2] += 20  
      
    set_user_origin( id, iOrigin )//Функция из модуля fun  
}
```
  
На этом с расположениями и координатами закончим. Перейдем к векторам.  
  

## Векторы
  
До этого момента мы говорили о координатах. Мы имели дело с точками указывавшими на позицию в своей размерности(двухмерной или трехмерной). Когда мы имеем дело с позициями такими как позиция игрока в игровом мире или позиция HUD сообщения на экране, мы имеем дело со скалярными величинами 
Скалярная величина (от лат. scalaris — ступенчатый) в физике — величина, каждое значение которой может быть выражено одним действительным числом. То есть скалярная величина определяется только своим значением, в отличие от вектора, который кроме значения имеет направление. К скалярным величинам относятся длина, площадь, время, температура и т. д
То есть когда мы знаем координаты игрока (X, Y, Z) мы не можем знать куда и с какой скоростью перемещается.   
**Velocity** - векторная скорость.  
```
 new Float:fVelocity[3]  
fVelocity[0] = 100  
fVelocity[1] = 200  
fVelocity[2] = 0  
set_pev( id, pev_velocity, fVelocity )
```
  
После выполнения этого кода, наша скорость теперь (100, 200, 0).Это означает, что у нас есть скорость в направлении X 100 юнитов в секунду, Y-скорость 200 юнитов в секунду и Z-скорость 0 модулей в секунду.Числа непосредственно указывают величину скорости. Как мы можем найти направление? (У векторных значений есть и величина И направление. )  
  
Рассмотрим ситуацию на картинках:  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868452_5.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868452_5.png)  
Заметьте, что векторы запускаются в точке (0, 0, 0) и идут от нее.  
  
Чтобы получить направление,мы должны объединить все три вектора (X, Y и Z) в один.  
[![Урок 24. Позиция,скорость и углы в Half-Life \(Position, Velocity, and Angles\)](http://amxxmodx.ru/uploads/posts/2012-11/thumbs/1353868418_6.png)](http://amxxmodx.ru/uploads/posts/2012-11/1353868418_6.png)  
Теперь мы видим, что **Velocity** это векторное значение. Это означает, что можно получить величину и направление скорости.  
  

## Сравнение Speed и Velocity
  
**Speed** - скалярная величина. То есть она предоставляет только с какой скоростью двигается объект. И чтобы ее сохранить нужна переменная как эта ( дробная или для целых чисел)  
```
new Float:fSpeed
```
  
**Velocity** - векторная величина, что бы сохранить такую скорость, потребуется массив как этот:   
```
new Float:fVelocity[3]
```
  
Скорость(Speed) означает расстояние/время, как километры в час (km/h) или метры в секунду (m/s). Она не говорит, куда едите. В отличии от **Velocity**.  
  

### Получение скалярной скорости из векторной Speed из Velocity
  
Помните Пифагора? У него есть теорема:  

c * c = a * a + b * b
C в квадрате равняется А в квадрате плюс B в квадрате.  
Пропустим геометрию, кому интересно сам разберется, искали мы в общем следующее:  
```
new Float:fVelocity[3]  
  
// store some velocity into fVelocity  
  
// slow, inefficient way (but you get to see what it looks like)  
New Float:fSpeed = floatsqroot( fVelocity[0] * fVelocity[0] + fVelocity[1] * fVelocity[1] + fVelocity[2] * fVelocity[2] )  
  
// fast, efficient way  
New Float:fSpeed = vector_length( fVelocity )
```
  
  

### Получение направления из Velocity
  
В игре нет Севера, Юга, Востока и Запада. У нас есть только углы, таким образом, это - то, как мы будем представлять направление нашей скорости.  
Функция **vector_to_angle** поможет получить направление из Velocity  
```
new Float:fVelocity[3]  
new Float:fAngle[3]  
  
// store some velocity  
  
vector_to_angle( fVelocity, fAngle )
```
  
  
**Небольшой пример основанный на новых знаниях:**  
```
public UselessFunction( id )  
{  
    new Float:fOrigin[3]  
    new Float:fVelocity[3]  
      
    // save his origin  
    pev( id, pev_origin, fOrigin )//Получение координат позиции игрока  
      
    // создание случайного направления векторной скорости  
    fVelocity[0] = random_float( 100.0, 500.0 ) * ( random_num(0,1) ? 1.0 : -1.0 )  
    fVelocity[1] = random_float( 100.0, 500.0 ) * ( random_num(0,1) ? 1.0 : -1.0 )  
    fVelocity[2] = random_float( 100.0, 500.0 ) * ( random_num(0,1) ? 1.0 : -1.0 )  
      
    // Установка игроку случайно скорости  
    set_pev( id, pev_velocity, fVelocity )  
      
    // Вызвать функцию PutMeBackPLZ чеерз 2 секунды  
    set_task( 2.0, "PutMeBackPLZ", id, _:fOrigin, 3 )  
}  
//Вернет игрока в исходное положение.  
public PutMeBackPLZ( iOrigin[3], id )  
{  
    // set his origin, YAWN  
    set_pev( id, pev_origin, iOrigin )  
}
```
  
Описание всех функций вы найдете в соответствующих разделах.  
  

## Angles - Углы
  
Статья не дописана, есть желание дописать? будем очень рады!  
Оригинал стати:[alliedmods.net](http://amxxmodx.ru/engine/go.php?url=aHR0cDovL2ZvcnVtcy5hbGxpZWRtb2RzLm5ldC9zaG93dGhyZWFkLnBocD90PTkxNDc0)
