# SQL_ThreadQuery Функция готовит и выполняет поточный запрос к базе данных
[SQLx](http://amxxmodx.ru/sqlx/)
Отличительная особенность функции **SQL_ThreadQuery** заключается не в ее более сложном использовании, а в том что она создает поточный запрос к базе данных, то есть если запрос требует значительного времени а обработку, функция не " встанет" и не будет ждать ответа от сервера и не будет происходить задержка игры ( лаги ). Кроме того соединение с базой данных происходит каждый раз как и разъединение. То есть нет постоянного конекта с БД.  
  
Инфо из **sqlx.inc:**  

![](http://amxxmodx.ru/templates/3week92/dleimages/spoiler-plus.gif) [Показать / Скрыть текст](javascript:ShowOrHide\('sp908c5424b4e48f118de49c79472e31d4'\))
```
#define TQUERY_CONNECT_FAILED    -2  
#define TQUERY_QUERY_FAILED    -1  
#define TQUERY_SUCCESS        0  
/**  
 * Prepares and executes a threaded query.  
 * This will not interrupt gameplay in the event of a poor/lossed   
 *  connection, however, the interface is more complicated and   
 *  asynchronous.  Furthermore, a new connection/disconnection is   
 *  made for each query to simplify driver support.  
 * The handler should look like:  
 *  
 * @param failstate - One of the three TQUERY_ defines.  
 * @param query - Handle to the query, do not free it.  
 * @param error - An error message, if any.  
 * @param errnum - An error code, if any.  
 * @param data - Data array you passed in.  
 * @param size - Size of the data array you passed in.  
 * @param queuetime - Amount of gametime that passed while the query was resolving.  
 *   
 * public QueryHandler(failstate, Handle:query, error[], errnum, data[], size, Float:queuetime)  
 *  
 * Note! The handle you pass in is a DB Tuple, NOT an active connection!  
 * Note! The handle does not need to be freed.  
 * Also note: This function is not guaranteed to be in another thread  
 *  (in fact - it's not).  You're seeing data "after the fact",   
 *  and as such to execute another query you should run   
 *  SQL_ThreadQuery again with new data.  
 */
```

  
```
native SQL_ThreadQuery(Handle:db_tuple, const handler[], const query[], const data[]="", dataSize=0);
```
  
  
**Синтаксис:**  

SQL_ThreadQuery(Handle:db_tuple, const handler[], const query[], const data[]="", dataSize=0)
  

    * **Handle:db_tuple** - Кешированные данные о соединении с помощью функции [**SQL_MakeDbTuple**](http://amxxmodx.ru/sqlx/6-sql_makedbtuple.html)  

    * **const handler[]** - Имя функции обработчика  

    * **const query[]** - Массив с запросом  

    * **const data[]=""** - Дополнительные данные  

    * **dataSize=0** - Длина массива дополнительных данных  

Функция вызовет функцию из второго аргумента.  
  
**Функция обработчик:**  
**Синтаксис:**  

public QueryHandler(failstate, Handle:query, error[], errnum, data[], size, Float:queuetime)
  

    * **failstate** - Кака выполнен запрос, три варианта:  
```
#define TQUERY_CONNECT_FAILED    -2  
#define TQUERY_QUERY_FAILED    -1  
#define TQUERY_SUCCESS        0
```
  

    * **Handle:query** - Дескриптор к запросу, не обнуляете его  

    * **error[]** - Текст ошибки  

    * **errnum** - Номер ошибки  

    * **data[]** - Массив с данными  

    * **size** - Размер массива  

    * **Float:queuetime** - Время потраченное на обработку запроса  

  
  
**Тип функции:**  
Native  
  
**Пример:**  
```
/* Plugin generated by AMXX-Studio */  
  
#include <amxmodx>  
#include <amxmisc>  
#include <sqlx>  
  
#define PLUGIN "[SQLx.inc] SQL_ThreadQuery"  
#define VERSION "1.0"  
#define AUTHOR "Admin"  
  
new Handle:SQL_Tuple  
  
  
public plugin_init() {  
      
    register_plugin(PLUGIN, VERSION, AUTHOR)  
    register_cvar("SQLx_host","127.0.0.1")  
    register_cvar("SQLx_db","amxxmodx")  
    register_cvar("SQLx_user","admin")  
    register_cvar("SQLx_password","pass")  
      
}  
public plugin_cfg(){  
    new host[33],dbase[33],user[33],pass[33]  
    get_cvar_string("SQLx_host",host,30)  
    get_cvar_string("SQLx_db",dbase,30)  
    get_cvar_string("SQLx_user",user,30)  
    get_cvar_string("SQLx_password",pass,30)  
    SQL_Tuple = SQL_MakeDbTuple(host,user,pass,dbase) // Создание картежа данных для соединения с БД  
      
    //Создание массива и подготовка запроса  
    new query[256]  
    format(query,charsmax(query),"SELECT * FROM table")  
  
    //Дополнительные данные  
    new data[2]  
    data[0] = 44  
  
    //Выполнение запроса  
    SQL_ThreadQuery(SQL_Tuple,"QueryHandler",query,data,charsmax(data))  
}  
//Функция вызванная запросом  
public QueryHandler(FailState, Handle:Query, error[], err, data[], size, Float:querytime)  
{  
    //Если произошла ошибка  
    if(FailState != TQUERY_SUCCESS)  
    {  
        log_amx("sql error: %d (%s)", err, error)  
        return  
    }  
  
    //Ошибки не было и если результат не нулевой  
    if( SQL_NumResults(Query) > 0 )  
        server_print("Sql result [%d] data[%d]",SQL_NumResults(Query),data[0])  
  
}
```
  
  
**Описание:**  
Прежде чем компилировать плагин, заполните необходимы графы для соединения с базой данных, а так же укажите таблицу в экспериментальном запросе.  
Сделали? Поехали дальше:  
В принципе если внимательно посмотреть на код, то все становится понятным и без лишних объяснений.  
Хочу лишь обратить внимание на то, что функция вызывает запрос где то в коде, а работа с результатом происходит в другой, указанной вами функции.  
Что в некоторых случая тоже очень удобно.  
  
Другие примеры использования вы можете посмотреть в плагине climb и других плагинах.
